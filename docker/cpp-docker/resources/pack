#!/usr/bin/env python3
import sys
import re

def write_f(fn,content):
    with open(fn,"w") as f:
        f.write(content)

def read_f(fn):
    with open(fn,"r") as f:  
        txt = f.readlines()
        txtblock="".join(txt)
        return txtblock

def extract_code_to_files(fn,lang):
    pat_cpp_code = r"(?<=```" + lang + r")(.*?(\.h|\.cpp))(.*?)(?=```\n)"
    tuples = re.findall(pat_cpp_code,read_f(fn),flags=re.MULTILINE|re.DOTALL)
    for tuple in tuples:
        filename = tuple[0].strip()
        content = tuple[2]
        write_f(filename,content)

def pack(fn):
    import os;
    files = [ f for f in os.listdir(".") if re.match(r'.*\.(cpp|h)',f)]
    with open(fn,"w") as packed:
        for f in files:
            packed.write("```cpp " + f + "\n");
            packed.write(read_f(f));
            packed.write("```\n");

def unpack(fn):
    extract_code_to_files(fn,r"cpp")



#main
import argparse
parser = argparse.ArgumentParser()
parser.add_argument("problem")
parser.add_argument("-p", "--pack", action='store_true',help="pack c++ .h .cpp files to under ## SolutionCode ")
parser.add_argument("-u", "--unpack", action='store_true',help="extract c++ .h .cpp files from ## SolutionCode ")
args = parser.parse_args()
pspec = args.problem + "Spec.md"
psolution = args.problem + "Solution.md"

if args.pack:
    pack(psolution)  
elif args.unpack:
    unpack(psolution)  








