# P3 - Merge Sorted Linked-lists

## Description 

Merge K sorted linked-lists into one sorted linked-list.

## Problem

You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.

Merge all the linked-lists into one sorted linked-list and return it.

 

Example 1:

Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation: The linked-lists are:
[
  1->4->5,
  1->3->4,
  2->6
]
merging them into one sorted list:
1->1->2->3->4->4->5->6
Example 2:

Input: lists = []
Output: []
Example 3:

Input: lists = [[]]
Output: []
 

Constraints:

k == lists.length
0 <= k <= 10^4
0 <= lists[i].length <= 500
-10^4 <= lists[i][j] <= 10^4
lists[i] is sorted in ascending order.
The sum of lists[i].length won't exceed 10^4.

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        
    }
};
```


## Solution API

```cpp
//P3.h
#ifndef P3_H 
#define P3_H
#include "RuSoe573.h"
#include <vector>
#include <string>

namespace dsalgo {
namespace P3 {

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

class Solution{ 
public: 
    Solution(const std::string solutionDesc): 
        descriptor{"P3 - Merge Sorted Linked-lists",solutionDesc}{}; 
    virtual ListNode* mergeKLists(std::vector<ListNode*>& lists)=0; 
    const SolutionDescriptor descriptor; 
};
class SolutionFactory {
public:
    static std::vector<Solution*>& getSolutions() {return solutions;}; 
private:
    static std::vector<Solution*> solutions;  
};

};};

#endif /*P3_H*/
```

```cpp
//RuSoe573.h

#ifndef RU_SOE_573_H 
#define RU_SOE_573_H 

#include <vector>
#include <string>
#include <iostream>
namespace dsalgo {

struct SolutionDescriptor {
    const std::string problemDesc;
    const std::string solutionDesc;
};

} 

#endif /* RU_SOE_573_H */
```


## Solution Impl


You are required to provide

* PxSolutionImpl.h
    * This should include all your class/type definitions.
* PxSolutionImpl.cpp
    * This should include all your implmentation code
    * Do not forget to initialize SolutionFactory static fields.
* Wrap each file inside this markup

```cpp
//yourFileName    
yourcode goes here
```


## Test Output


You may provide

* Your test/main output
* With any design/format you feel helpful to readers



## Analysis


You may provide 

* Your data structure/algorithms design
* Your algo performance analysis



## Environment


Instructor's programming environment:

* OS:
    * ubuntu:22.04 docker image
    * macOSX Monterey on M1 chip
* Compiler: 
    * clang latest
* C++:
    * c++17



## Notes


You may provide

* Your notes here  



## Submission


Your submission is through Canvas currently.

* Required:
    * This markdown file 
* Optional:
    * Separately, a zip of your project folder without binary. 



## Sample Solution Impl

```cpp
//P1SolutionImpl.cpp

#include "P1SolutionImpl.h" 
#include "P1.h"
using namespace dsalgo::P1;
///////////////// MyBetterSolution ////////////////// 
std::vector<int> S2::twoSum(std::vector<int>& nums, int target) {
    std::map<int,int> res_hash;
    std::vector <int> result;
    int i;
    for(i=0;i<nums.size();i++)
    {
        if(res_hash.find(target-nums[i])!=res_hash.end())
        {
            
            result.push_back(res_hash[target-nums[i]]);
            result.push_back(i);
            return result;
        }
        else
            res_hash[nums[i]] = i;
    }       
    return result; 
}


/////////////// MyBruteForceSolution /////////////// 
std::vector<int> S1::twoSum(std::vector<int>& nums, int target) {
    std::map<int,int> res_hash;
    std::vector <int> result;
    int i;
    for(i=0;i<nums.size();i++)
    {
        if(res_hash.find(target-nums[i])!=res_hash.end())
        {
            
            result.push_back(res_hash[target-nums[i]]);
            result.push_back(i);
            return result;
        }
        else
            res_hash[nums[i]] = i;
    }       
    return result; 
}

/////////////// Static Initialization /////////////// 
std::vector<Solution*> SolutionFactory::solutions{ new S1(), new S2() };

```

```cpp
//P1SolutionImpl.h
#ifndef P1_SOLUTION_IMPL_H
#define P1_SOLUTION_IMPL_H
#include "P1.h"
#include <vector>
#include <map>
namespace dsalgo {
namespace P1 {

class S1: public Solution {
public:
    S1():Solution("A hash map approach"){}
    std::vector<int> twoSum(std::vector<int>& nums, int target); 
};

class S2: public Solution  {
public:
    S2():Solution("My brute force solution"){}
    std::vector<int> twoSum(std::vector<int>& nums, int target); 
};

};};


#endif /* P1_SOLUTION_IMPL_H */
```
