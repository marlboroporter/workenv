# P3 - Merge Sorted Linked-lists

## Description 

Merge K sorted linked-lists into one sorted linked-list.

## Problem

You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.

Merge all the linked-lists into one sorted linked-list and return it.

 

Example 1:

Input: lists = [[1,4,5],[1,3,4],[2,6]]
Output: [1,1,2,3,4,4,5,6]
Explanation: The linked-lists are:
[
  1->4->5,
  1->3->4,
  2->6
]
merging them into one sorted list:
1->1->2->3->4->4->5->6
Example 2:

Input: lists = []
Output: []
Example 3:

Input: lists = [[]]
Output: []
 

Constraints:

k == lists.length
0 <= k <= 10^4
0 <= lists[i].length <= 500
-10^4 <= lists[i][j] <= 10^4
lists[i] is sorted in ascending order.
The sum of lists[i].length won't exceed 10^4.

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        
    }
};
```


## Solution API

```cpp
//P3.h
#ifndef P3_H 
#define P3_H
#include "RuSoe573.h"
#include <vector>
#include <string>

namespace dsalgo {
namespace P3 {

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

class Solution{ 
public: 
    Solution(const std::string solutionDesc): 
        descriptor{"P3 - Merge Sorted Linked-lists",solutionDesc}{}; 
    virtual ListNode* mergeKLists(std::vector<ListNode*>& lists)=0; 
    const SolutionDescriptor descriptor; 
};
class SolutionFactory {
public:
    static std::vector<Solution*>& getSolutions() {return solutions;}; 
private:
    static std::vector<Solution*> solutions;  
};

};};

#endif /*P3_H*/
```

```cpp
//RuSoe573.h

#ifndef RU_SOE_573_H 
#define RU_SOE_573_H 

#include <vector>
#include <string>
#include <iostream>
namespace dsalgo {

struct SolutionDescriptor {
    const std::string problemDesc;
    const std::string solutionDesc;
};

} 

#endif /* RU_SOE_573_H */
```


## Solution Impl

```cpp
//P3SolutionImpl.h
#ifndef P3_SOLUTION_IMPL_H 
#define P3_SOLUTION_IMPL_H
#include "P3.h"
namespace dsalgo {
namespace P3 {

class S1: public Solution{
public:
     S1():Solution("My solution 1"){}
     virtual ListNode* mergeKLists(std::vector<ListNode*>& lists); 
};

class S2: public Solution{
public:
     S2():Solution("My solution 2"){}
     virtual ListNode* mergeKLists(std::vector<ListNode*>& lists){return nullptr;}; 
};

};};


#endif /* P3_SOLUTION_IMPL_H */
```

```cpp
//P3SolutionImpl.cpp
#include "P3SolutionImpl.h" 
#include "P3.h"
#include "RuSoe573.h" 

using namespace dsalgo; 
using namespace dsalgo::P3; 

ListNode* S1::mergeKLists(std::vector<ListNode*>& lists)
{
    return nullptr;  

};

////////////////////// !!!!! /////////////////
std::vector<Solution*> SolutionFactory::solutions { new S1(), new S2() };
```


## Test Output


You may provide

* Your test/main output
* With any design/format you feel helpful to readers



## Analysis


You may provide 

* Your data structure/algorithms design
* Your algo performance analysis



## Environment


Instructor's programming environment:

* OS:
    * ubuntu:22.04 docker image
    * macOSX Monterey on M1 chip
* Compiler: 
    * clang latest
* C++:
    * c++17



## Notes


You may provide

* Your notes here  



## Submission


Your submission is through Canvas currently.

* Required:
    * This markdown file 
* Optional:
    * Separately, a zip of your project folder without binary. 

